\section{Future Research}

\subsection{Post-quantum algebraically-friendly SNARKs}
\noindent Though multiple of the SNARKs discussed are practical from a performance standpoint, quantum computers may render them useless from a security standpoint in the near future. As a result, there is a strong effort to develop efficient enough post-quantum SNARKs. To this end, many works \cite{starks, ligero, fractal, spartan} use hashing-based cryptography relying on hash function collision-resistance, an assumption believed to hold against quantum adversaries. The common denominator is to reduce testing computational integrity to hashing-based polynomial proximity testing via methods like FRI \cite{FRI}, which involve merkle tree commitments to Reed-Solomon codewords of witness polynomials. While such approaches are believed to be post-quantum secure, their use cryptographic primitive affording no algebraic structure hinders the attainment of smaller proof elements / faster verification. The most interesting direction addressing these issues involves SNARK constructions using lattice-based cryptography, which use algebraic objects but derive security from different post-quantum assumptions. Albrecht et al. \cite{lattice1} made some progress in this direction via a lattice-based SNARK with logarithmic-time verification. As it is operating over a completely different algebraic object, this method uses a completely different set of security assumptions than those discussed prior -- namely, generalizations of the short integer solution (SIS) problem. Future work that quantifies the security assumptions in this area and decreases prover/verifier complexity would bring SNARKs with efficiency imposed by algebraic structure and post-quantum security to reality, which the blockchain ecosystem would eventually accept given sufficient tooling and support.

\subsection{Automated verification of SNARK methods/applications}
\noindent Currently, several layer 2 blockchains collectively hold tens of billions of dollars \textbf{[CITE]} protected by the integrity of SNARK methods used to verify block validity; if either the methods or their implementations have soundness bugs, it could allow a knowledgeable adversary to prove an invalid state transition for financial gain, likely causing massive financial loss to users in the process. \\

\noindent One approach to mitigate these risks is through formally verifying the behavior of SNARK methods and their implementations, especially in verifiable virtual machines. This way, we can have formal guarantees that such systems obey certain invariants mitigating various attack vectors and otherwise catastrophic impacts. There are two noteworthy and related directions of ongoing work in this domain. The first is related to formally verifying the SNARK methods themselves in various cryptographic models. An example of this is ArkLib by Dao et al. \cite{arklib}, a modular attempt to formally verify argument systems using the Lean proving assistant \cite{lean4}. Though very promising and easily updatable, there are still many gaps to fill. Furthermore, the periodic introduction of new methods will require constant updates to the relevant types and theorems. Nonetheless, seeking formal guarantees on SNARK behavior in various mechanized theoretical models will make them increasingly fit for use in large-scale DeFi infrastructure/applications needing to verify computation. \\

\noindent The other direction concerns automated verification of VVM correctness. A notable example of this is Picus by Pailoor et al. \cite{picus} which uses symbolic execution and SMT solving to detect nondeterministic behavior in the circuit used by verifiable virtual machines to constrain execution traces. As we have seen in prior methods, the circuit structure directly influences the terms the verifier uses to check proofs, whether through the trusted setup in the non-univeral case or the committed proof elements in the universal case. Checking that a given circuit configuration can produce at most one circuit output reduces the likelihood that some circuit value is underconstrained, thus making it more difficult to produce a proof from an tampered witness which passes verification. Picus has been used heavily in verifying Risc Zero VM \cite{risc0}, and similar efforts exist for JOLT zkVM \cite{jolt, joltfv} lookup-based arguments. Preliminary work by Chaliasos et al. \cite{sok} has found that circuit-related soundness bugs are the most frequent kind of bug by a huge margin, suggesting that building upon this existing work will be important for the security of VVMs. For instance, it would be useful to build upon Picus and other tools of this nature so that they can detect nondeterminism in more complex circuits.

% \subsection{Integration of optimizations to pairing-based cryptography}
% \noindent optimize miller function\\
%
% \subsection{Standardized benchmarks for pairing-based methods (and others)}
% \noindent Current SNARK benchmarks lack standardization by the computation being verified.\\


% \subsection{Proof aggregation \& Distributed Proving}
% \noindent As one would expect, proof generation remains the performance bottleneck in most SNARKs (pairing-based or not). In a world where computational resources are quite asymmetrically distributed (DeFi being no exception), it would be sensible to be able to outsource more intensive computations within the same proof to another party; naturally they would include a proof that such computation was done correctly. \textbf{Is there any work on this right now}. A similar idea emerges when we consider distributed proving of a statement by segmenting the \textit{statement} instead of the \textit{proof components}. Each delegated prover would then have to prove that a given subcircuit has an assignment which produces some desired value, then all of these proofs would get aggregated along with a proof that the aggregation was performed correctly.\\
%
%
% \subsection{Extending pairings to higher-degree operations}
% \noindent nothing\\
