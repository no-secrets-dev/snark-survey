\section{Future Research}

\subsection{Post-quantum algebraically-friendly SNARKs}
\noindent Though multiple of the SNARKs discussed are practical from a performance standpoint, quantum computers may render them useless from a security standpoint in the near future. As a result, there is a strong effort to develop efficient enough post-quantum SNARKs. To this end, many works \cite{starks, ligero, fractal, spartan, jolt} use hashing-based Reed-Solomon proximity testing methods \cite{fri}, which relies on the hardness of computing hash function collisions. While such approaches are believed to be post-quantum secure, the cryptographic primitives used offer no additively homomorphic structure enabling the recursive composition of smaller proof elements \& faster verification we see in pairing-based methods. Albrecht et al. \cite{lattice1} made some progress in this direction via a lattice-based SNARK with logarithmic-time verification; it derives security from the hardness of the short integer solution (SIS) problem in lattices. Future work that decreases prover/verifier complexity could realize practical SNARKs using additively homomorphic post-quantum encryption, which virtually every blockchain would need in a post-quantum era.

\subsection{Automated verification of SNARK methods/applications}
\noindent Layer 2 blockchains collectively hold tens of billions of dollars \cite{l2beat} protected by the integrity of SNARK methods used to verify block validity; if the methods/implementations have soundness bugs, an adversary could prove an invalid state transition for financial gain and steal funds. There are two promising avenues to mitigate this risk. The first is formal verification of SNARKs in mechanized cryptographic models using Lean 4 and other methods \cite{arklib, lean4, joltfv}. Though very promising and easily updatable, there are still many gaps to fill. Furthermore, the periodic introduction of new methods will require constant updates to the relevant types and theorems. Nonetheless, seeking formal guarantees on SNARK behavior could eliminate entire classes of soundness bugs in L2-related implementations, lowering risks of fund theft. The second and more targeted direction concerns automated detection of nondeterministic circuit behavior using symbolic execution and SMT solvers. An example of this is Picus \cite{picus}, which has been used to verify parts of the Risc Zero VM \cite{risc0}. Preliminary work by Chaliasos et al. \cite{sok} has found that circuit-related soundness bugs are the most frequent kind of bug by a huge margin, suggesting that building upon this existing work will be important especially as zkVM implementations become more complex. LogUp-based arguments \cite{logup} for zkVMs like SP1 \cite{sp1} based on interacting sub-witnesses would be a necessary target of future work in this domain.

% \subsection{Integration of optimizations to pairing-based cryptography}
% \noindent optimize miller function\\
%
% \subsection{Standardized benchmarks for pairing-based methods (and others)}
% \noindent Current SNARK benchmarks lack standardization by the computation being verified.\\


% \subsection{Proof aggregation \& Distributed Proving}
% \noindent As one would expect, proof generation remains the performance bottleneck in most SNARKs (pairing-based or not). In a world where computational resources are quite asymmetrically distributed (DeFi being no exception), it would be sensible to be able to outsource more intensive computations within the same proof to another party; naturally they would include a proof that such computation was done correctly. \textbf{Is there any work on this right now}. A similar idea emerges when we consider distributed proving of a statement by segmenting the \textit{statement} instead of the \textit{proof components}. Each delegated prover would then have to prove that a given subcircuit has an assignment which produces some desired value, then all of these proofs would get aggregated along with a proof that the aggregation was performed correctly.\\
%
%
% \subsection{Extending pairings to higher-degree operations}
% \noindent nothing\\
