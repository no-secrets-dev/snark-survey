\section{Future Research}

\subsection{Post-quantum algebraically-friendly SNARKs}
\noindent Though multiple of the SNARKs discussed are practical from a performance standpoint, quantum computers may render them useless from a security standpoint in the near future. As a result, there is a strong effort to develop efficient enough post-quantum SNARKs. To this end, many works \cite{starks, ligero, fractal, spartan, jolt} use hashing-based based Reed-Solomon proximity testing methods \cite{fri}, which relies on the hardness of computing hash function collisions. While such approaches are believed to be post-quantum secure, the cryptographic primitives used offer no additively homomorphic structure enabling the recursive composition of smaller proof elements \& faster verification we see in pairing-based methods. Albrecht et al. \cite{lattice1} made some progress in this direction via a lattice-based SNARK with logarithmic-time verification; it derives security from the hardness of the short integer solution (SIS) problem in lattices. Future work that quantifies the security assumptions in this area and decreases prover/verifier complexity could realize practical SNARKs using additively homomorphic post-quantum encryption, which the blockchain ecosystem would eventually accept given sufficient tooling and support.

\subsection{Automated verification of SNARK methods/applications}
\noindent Currently, several layer 2 blockchains collectively hold tens of billions of dollars \cite{l2beat} protected by the integrity of SNARK methods used to verify block validity; if either the methods or their implementations have soundness bugs, it could allow a knowledgeable adversary to prove an invalid state transition for financial gain, causing massive financial loss to users and the chain. There are two noteworthy and related directions of ongoing work in this domain. The first is related to formally verifying the SNARK methods themselves in various mechanized cryptographic models using Lean 4 \cite{arklib, lean4} and other techniques for lookup-based arguments, as done with JOLT zkVM \cite{jolt, joltfv}. Though very promising and easily updatable, there are still many gaps to fill. Furthermore, the periodic introduction of new methods will require constant updates to the relevant types and theorems. Nonetheless, seeking formal guarantees on SNARK behavior in various mechanized theoretical models will make them increasingly fit for use in large-scale DeFi infrastructure/applications needing to verify computation. A more adversarial direction concerns automated detection of missing circuit constraints \cite{picus}, which detect nondeterministic circuit behavior using symbolic execution and SMT solvers. Picus has been used heavily in verifying Risc Zero VM \cite{risc0} Preliminary work by Chaliasos et al. \cite{sok} has found that circuit-related soundness bugs are the most frequent kind of bug by a huge margin, suggesting that building upon this existing work will be important for the security of VVMs. For instance, it would be extremely useful to have tools detect missing constraints in circuits validating interacting sub-witnesses like in the STARK-based SP1 zkVM architecture, which uses LogUp \cite{logup} to verify correctness of interactions.

% \subsection{Integration of optimizations to pairing-based cryptography}
% \noindent optimize miller function\\
%
% \subsection{Standardized benchmarks for pairing-based methods (and others)}
% \noindent Current SNARK benchmarks lack standardization by the computation being verified.\\


% \subsection{Proof aggregation \& Distributed Proving}
% \noindent As one would expect, proof generation remains the performance bottleneck in most SNARKs (pairing-based or not). In a world where computational resources are quite asymmetrically distributed (DeFi being no exception), it would be sensible to be able to outsource more intensive computations within the same proof to another party; naturally they would include a proof that such computation was done correctly. \textbf{Is there any work on this right now}. A similar idea emerges when we consider distributed proving of a statement by segmenting the \textit{statement} instead of the \textit{proof components}. Each delegated prover would then have to prove that a given subcircuit has an assignment which produces some desired value, then all of these proofs would get aggregated along with a proof that the aggregation was performed correctly.\\
%
%
% \subsection{Extending pairings to higher-degree operations}
% \noindent nothing\\
